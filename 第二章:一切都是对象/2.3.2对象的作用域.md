## 2.3.2 对象的作用域

- Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活干作用域之外。所以假如你采用代码
```java
{
    String s = new String("a string"):
}// End of scope
```

- 引用s在作用域终点就消失了。然而，s指向的string对象仍继续占据内存空间。在这一小段代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域的范国。在后继章节中，读者将会看到：在程序执行过程中；怎样传递和复制对象引用。

- 事实证明，由new创建的对象，只要你需要，就会一直保留下去。这样，许多C++编程问題在lava中就完全消失了。在C++中，你不仅必须要确保对象的保留时间与你需要这些对象的时间一样长，而且还必须在你使用完它们之后，将其销毀。

- 这样便带来一个有趣的问题。如果JavaL对象继续存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的向题。这也是Java神奇之所在。**Java有一个拉圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供共他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对象，一旦不再需要，它们就会自行消失。这样做就消除了这类编程问题(即“内存泄漏”），这是由于程序员忘记释放内存而产生的问题。**
  
## 小结
- Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活干作用域之外。
- 事实证明，由new创建的对象，只要你需要，就会一直保留下去。
- Java有一个拉圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供共他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对象，一旦不再需要，它们就会自行消失。这样做就消除了这类编程问题(即“内存泄漏”），这是由于程序员忘